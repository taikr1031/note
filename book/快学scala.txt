第一章 基础
	鼓励使用val，除非你真的需要改变他的内容。
	不需要给出值或变量的类型，可以通过初始化他的表达式中推断出来。不过，在必要的时候，也可以指定类型。
	Scala有7种类型：Byte,Char,Short,Int,Long,Float,Double。以及一个Boolean类型。跟JAVA不同，这些类型是类。
	Scala不需要包装类型，在基本类型和包装类型之间转换是Scala编译器的工作。
	Scala用方式而不是强制类型转换来做数值之间的转换。
	Scala没有静态方法，但是有类似的“单例对象”。一个类对应一个伴生对象，其方法就跟JAVA中的静态方法一样。
	没有参数且不改变当前对象的Scala方法通常不带圆括号。

第二章 控制结构和函数
	if表达式也有值
	块也有值--是他最后一个表达式的值
	Scala的for循环就像是“增强版”的JAVA FOR循环。
	void类型是unit。
	避免在函数定义中使用return。
	注意别在函数定义中漏掉=。
	Scala没有受检异常。
	每个表达式都有一个类型，混合类型表达式的类型是多个分支类型的公共型超类Any。
	Unit == void
	只要函数不是递归的，就不需要指定返回类型。
	变长参数函数得到的是一个类型为Seq的参数。
	序列：head是第一个元素，tail是所有其他元素的序列，这又是一个Seq，我们用 _* 来将他转换成参数序列。
	对于不返回值的函数，函数体包含在花括号当中但没有前面的 = 号，那么返回值就是Unit。这样的函数叫过程(procedure)
	懒加载：lazy val words = ...

第三章 数组相关操作
	若长度固定则使用Array，如长度有变则使用ArrayBuffer。
	提供初始值时不要使用new。
	用()来访问元素。
	
第四章 映射和元祖
	不可变映射：val scores = Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)
	可变映射：  val scores = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)
	空映射：    val scores = new scala.collection.mutable.HashMap[String, Int]
	val bobScore  = scores.getOrElse("Bob", 0)
	和数组和字符串中的位置不同，元组的各组元是从1开始，而不是0。

第五章 类
	改值器 方法名()		取值器 方法名
	在实现属性时有如下四种方式（一个属性不能只写gettter不写setter方法）：
	1)var foo： scala自动合成一个getter和一个getter。
	2)val foo： scala自动合成一个getter。
	3)由你来定义foo和foo_=方法。
	4)有你来定义foo方法。
	辅助构造器的名称为this，每个辅助构造器必须以一个先前定义的其他辅助构造器或主构造器的调用开始。
	1)主构造器的参数直接放置在类名之后。
	2)主构造器会执行类定义中的所有语句。
	3)如果不带val或var的构造参数至少被一个方法所使用，它将升格为字段。否则仅是被主构造器中的代码访问的普通参数。
	私有主构造器：class Person private(val id: Int) {...}。这样用户就必须通过辅助构造器来构造Person对象。
	
第六章 对象
	Scala没有静态方法和静态字段，可以通过object实现。
	类和他的伴生对象可以相互访问私有特性，但他们必须存在同一个源文件中。
	对象用途：
	1)存放工具函数或常量
	2)高效的共享单个不可变实例
	3)需要用单个实例来协调某个服务时（参考单例模式）
	
第七章 包和引用
	源文件的目录和包之间并没有强制关系。你不需要将Employee.scala和Manager.scala放在同一个包目录下。
	换个角度讲，你可以在同一个文件当中为多个包做贡献。
	串联式包语句：package com.horstmann.impatient {}。现在com.horstmann.collection包不再能够以collection访问到了。
	把工具函数和常量添加到包（包对象）而不是某个Utils对象更加合理。每个包都可以有一个包对象。
	引入包中几个成员：import java.awt.{Color, Font}
	引入包重命名：	import java.util.{HashMap => JavaHashMap}
					import scala.collention.mutable._
	引入隐藏：		import java.util.{HashMap => _, _}
					import scala.collention.mutable._
					
第八章 继承
	extends,final关键字和java中相同
	重写一个非抽象方法是必须用override
	只有主构造器可以调用超类的主构造器
	可以重写字段
	
第十章 特质
	类可以实现任意数量的特质
	特质可以要求实现他们的类具备特定的字段、方法或超类
	和java接口不同，特质可以提供方法或字段的实现
	当你将多个特质叠加在一起时，顺序很重要，其方法先被执行的特质排在更后面
	特质中中不需要将方法申明成abstract，以为未被实现的方法默认就是抽象方法，当子类重写抽象方法时不需要给出override关键字
	特质不能有构造器参数，每个特质都有一个无参的构造器。解决方法一：提前定义。二：构造器中使用懒值
	
第十一章 操作符

第十二章 高阶函数
	在Scala中函数是“头等公民”，就和数字一样
	你可以创建匿名函数，通常还会把他们交给其他函数
	函数参数可以给出需要稍后执行的行为
	许多集合方法都接受函数参数，将函数应用到集合中的值
	有很多语法上的简写让你以简短且易读的方式表达函数参数
	你可以创建操作代码块的函数，他们看上去就像是内建的控制语句
	在Scala中，无法直接操作方法，只能直接操作函数
	由于函数是一个接受函数参数的函数，因此称为高阶函数
	闭包由代码和代码用到的任何非局部变量定义构成。这些函数是以类的对象方式实现的，该类有一个实例变量factor和一个包含了函数体的apply的方法
	科里化是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原来第二个参数作为参数的函数
	
第十三章 集合
	所有集合都扩展自Iterable特质
	集合有三大类，分别为序列、集合映射
	对于几乎所有集合类，Scala都同时提供了可变和不可变的版本
	Scala列表要么是空的，要么拥有一头一尾，其中尾部本身又是一个列表
	集合是无先后次序的集合
	用LinkedHashSet来保留插入顺序，或者用SortedSet来按顺序进行迭代
	+将元素添加到无先后次序的集合中；+:和:+向前或向后追加到序列；++将两个集合串接到一起；-和--移除元素
	Iterable和Seq特质有数十个常见操作的方法，在编写冗长繁琐的循环码之前，先看看这些方法是否满足你的需要
	映射、折叠和拉链操作是很有用的技巧，用来将函数或操作应用到集合中的元素
	
	
	
	


其他
	在REPL粘贴成块代码：
	scala> :paste
	// Entering paste mode (ctrl-D to finish)
