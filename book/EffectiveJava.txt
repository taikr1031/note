第二章：创建和销毁对象
第1条：考虑用静态工厂方法代替构造器。
	静态工厂优点：
	1、有名称；2、不必再每次调用他们的时候都创建一个新对象；3、他们可以返回原返回类型的任何子类型的对象；
	4、在创建参数化类型实例时，使代码变得更加简洁。
	静态工厂缺点：
	1、类如果不含公有的或者受保护的构造器，就不能被子类化；2、他们与其他普通静态方法没有区别。
	
第2条：遇到多个构造器参数时要考虑用构建器
	如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是不错的选择，特别是大多数参数都是可选时。
	1、重叠构造器模式可行，但是当有许多参数时，客户端代码很难编写和阅读。
	2、JavaBeans模式，调用一个无参构造器来创建对象，然后调用setter方法设置每个必要的参数值。
	3、最好采用Builder模式。模拟了具名的可选参数。缺点：代码冗长，只有在参数大于4个以上的情况下使用。

第3条：用私有构造器或者枚举类型强化Singleton属性

第4条：通过私有构造器强化不可实例化的能力
	工具类不希望被实例化，实例化对他没有任何意义。然后在缺少显示构造器的情况下，编译器会自动提供一个公有的，无参的构造器。因此必须创建一个私有构造器，他就不会实例化了。
	企图通过将类做成抽象类来强制该类不可被实例化，这是行不通的。因为该类可以被子类化，并且该子类也可以实例化。
	
第5条：避免创建不必要的对象
    最好能重用对象而不是在每次需要的时候就创建一个相同功能的对象。
    要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。
    除非是非常重量级的对象创建，比如数据库连接池。否则维护自已的对象池会把代码弄得很乱，同时增加内存占用，并且损害性能。现代JVM实现具有高度优化的垃圾回收器，其性能很容易超过轻量级对象池的性能。
    String s = new String("abc"); //don't do this
    String s = "abc"; //ok
    
第6条：消除过期的对象引用
    过期引用，只要类是自已管理类存，程序员就要警惕内存泄露问题。一旦元素被释放掉，该元素中包含的所有对象都应该被清空。
    内存泄露的另一个来源是缓存。WeakHashMap.
    第三个常见来源是监听器和其他回调。WeakHashMap.
  
第7条：避免使用终结方法

第3章：对于所有对象都通用的方法
第8条：覆盖equals时请遵守通用约定
	equals方法实现了等价关系：自反性、对称性、传递性、一致性。
第9条：覆盖equals时总要覆盖hashCode
第10条：始终要覆盖toString
第11条：谨慎的覆盖clone
第12条：考虑实现Comparable接口
	
第4章：类和接口
第13条：使类和成员的可访问性最小化
	可访问性：私有的、包级私有(默认)、受保护的、公有的
	
第14条：在公有类中使用访问方法而非公有域
	如果类可以在他所在包的外部进行访问，就提供访问方法。共有类永远都不应该暴漏可变的域。
	如果类是包级私有的，或者是私有的嵌套类，直接暴漏他的数据域并没有本质的错误。

第15条：使可变性最小化
	为了使类称为不可变，需要遵循以下五点：
	1.不要提供任何会修改对象状态的方法。
	2.保证类不会被扩展。
	3.是所有域都是final的
	4.是所有域都是私有的
	5.确保对于任何可变组件的互斥访问
	不可变对象本质上是线程安全的，他们不需要同步。可以被自有共享。
	缺点：对于每个不同的值都需要一个单独的对象。
	
	

    
