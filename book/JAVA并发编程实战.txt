<>简介：
	操作系统的出现计算器可以实现多个程序同时运行，并且不同的程序都在单独的进程中运行；操作系统为各个独立执行的进程分配各种资源，包括内存、文件句柄以及安全证书等。如果需要，在不同的进程之间可以通过一些粗粒度的通讯机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。

	线程允许在同一个进程中同时存在多个程序控制流。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈、局部变量等。线程还提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性。而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。
	线程也称为轻量级进程，在大多数现代操作系统中，都是以线程为基本调度单位，而不是进程。同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象。
	线程可以有效的降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好的模拟人类的工作方式和交互方式。此外，线程还可以降低代码的复杂度，使代码能够更容易编写、阅读和维护。

线程的优势：	
	1、发挥多处理器的强大能力：由于程序的基本调度单位是线程，因此如果在程序中只有一个线程，那么最多同时只能在一个处理起上运行。在拥有100个处理器的系统上，将有99%的资源无法使用；使用多线程还有助于在单个处理器系统上获得更高的吞吐量，如当一个线程在等待I/O时，另一个线程可以继续运行。
	2、建模简单性：如果为模型中的每种类型的任务都分配一个专门的线程，可以形成一种串行的假象，并将程序的执行逻辑与调度机制的细节，交替执行的操作，异步I/O以及资源等待等问题分离开来。
	3、异步事件的简化处理：服务器应用程序在接受来至多个远程客户端的套接字连接请求时，如果为每个连接都分配其各自的线程并且使用同步I/0，那么就会降低这类程序的开发难度。
	4、相应更灵敏的用户界面：在现代GUI框架中，例如AWT和Swing等工具，都采用一个事件分发线程，来代替主事件循环。将长时间运行的任务放在一个单独的线程中运行，那么事件线程就能及时的处理其他界面事件，从而使用用户界面具有更高的灵敏度。

线程的风险：
	1、安全性问题（永远不要发生糟糕的事情）：多线程共享变量需要加同步方法 sync。
	2、活跃性问题（某件正确的事情最终会发生）：死锁、饥饿、活锁。
	3、性能问题（某件正确的事情是否足够好）：时长、吞吐率、资源消耗、可伸缩性。

<>第2章：线程安全性
	如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有3种方式可以修复这个问题。
		1、不再线程之间共享该状态变量。
		2、将状态变量修改为不可变的变量。
		3、在访问状态变量时使用同步。
	在设计线程安全的类时，良好的面向对象技术、不可修改性、以及明晰的不变性规范都能起到一定的帮组作用。
	线程安全性：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为。
	在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
	无状态对象一定是线程安全的。
	原子：假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完毕，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。
	在实际情况中，应尽可能的使用现有的线程安全对象，来管理类的状态。
	要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
	对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护。	每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
	对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
	通常，在简单性与性能之间存在相互制约的因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能会破环安全性）。
	当执行时间较长或者无法快速完成的操作（例如，网络I/0或控制台I/0），一定不要持有锁。

<>第3章：对象的共享
	可见性：我们不但希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的变化。为了确保多个线程之间对内存写入操作的可见性，必须采用同步机制。
	在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。
	加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
	仅当volatile变量能简化代码的实现以及同步策略的验证时，才应该使用他。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。volatile 变量的正确使用方式包括：确保他们自身的可见性，确保他们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如初始化或关闭）。
	加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保原子性。
	不要在构造函数中使用 this 引用逸出。当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象，即使发布对象的语句位于构造函数的最后一行也是如此。在构造函数中创建线程没有错误，但不要立即启动它。而是通过一个 start 或 initialize 方法来启动。
	不可变对象一定是线程安全的。不可变对象很简单，就是只由一种状态，并且该状态由构造函数来控制。
	当满足以下条件时，对象才是不可变的：
		1、对象创建后其状态就是不可变的。
		2、对象的所有域都是 final 类型。
		3、对象时正确创建的（在对象创建期间， this 引用没有逸出）。
	final域：“除非需要更高的可见性，否则应将所有域都声明为 private”；“除非需要某个域是可变的，否则应将其声明为 final”。
	任何线程都可以在不需要额外同步的情况下安全的访问不可变对象。
	在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
		1、线程封闭：线程封闭的对象只用由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
		2、只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问。但任何线程都不能修改它。
		3、线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。
		4、保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及发布的并且由某个特定锁保护的对象。

 <>第四章：对象的组合
	
