分布式系统规划：
1、Redis加速：用Redis缓存来给WordPress站点加速-适用于Apache和Nginx
2、负载均衡：免费空间+便宜VPS和OpenResty,Ngx_lua,Redis搭建系统负载均衡环境
3、CDN加速：DNSPOD分布式解析+安全宝和Incapsula对搜索引擎分别CDN加速

分布式系统要去session化，即不能用session，因为session都在web服务器的内存中，如换了服务器就无法获取了。
mybaits适合于复杂SQL，方便DBA根据业务SQL调优。
springmvc中的get传参优先使用restful风格。
	@RequestMapping(value="toUpdate/{customerUuid}", method=RequestMethod=GET)
	public String toUpdate(Model model, @PathVariable("customerUuid") int customerUuid){
		...
	}

几种访问模式：()：存放内容；[]：作用
1.纯静态：
	Client->Nginx(本地静态资源文件)[动静分离]
2.纯动态，不能缓存：
	Client->Nginx(本地静态资源文件)[动静分离]->Tomcat(动态请求)->ActiveMQ->MemCache(数据库记录)[数据缓存]->MySql+MongoDB
3.部分动态，能缓存： 
	Client->Nginx(本地静态资源文件)[动静分离/负载均衡]->Varnish(内存静态/动态资源)[缓存]->Tomcat(动态请求)->ActiveMQ[异步]
	->MemCache(数据库记录)[数据缓存]->MySql+MongoDB


/********************************** Ngnix [31-40] ********************************** /
用途：1.反向代理、负载均衡、动静分离
			2.分布式部署、应用的垂直/水平切分、为应用系统向大规模架构变迁做好准备
			3.虽然动静分离也能多少提高一点性能，但Ngnix的主要关注点不是为了提高性能，而是是的系统的分布式，大规模部署成为可能
			4.在小系统上部署Nginx可能还会变慢，毕竟多了一层网络代理
1.轻量级Web服务器，也是一款轻量级的反向代理服务器。
2.作用: 直接支持Rails和PHP程序、负载均衡、邮件代理服务器、前端动静分离、...
3.特点: 高稳定、高性能、资源占用少、功能丰富、模块化结构、支持热部署
location: 一个类型请求只配置一个类型pattern请求处理。按文件后缀名分；按模块分
缓存一般都是针对get，post是客户端向服务端提交数据，不必缓存

静态服务器，apache和nginx优缺点：
nginx静态资源修改后如何保证后端和前端程序一直：
	1.Rsync做服务端自动同步或使用NFS、MFS分布式共享存储
	2.静态资源单独打包，发布到Nginx，动态程序发布到Tomcat
	
负载均衡：
	1.多个tomcat集群要做session复制，ip_hash（不推荐） 客户端的IP有可能变化
	2.轮训（设置权重）、geo、geoip
rewrite：
	用来执行URL重定向，利于去掉恶意访问的URL，有利于搜索引擎SEO
	Nginx使用的语法源于Perl兼容正则表达式
	
缓存动态内容（动态内容静态化）

Apache ab压力测试：/apache/bin/ab -n1000 -c10 http://localhost:8080/index.jsp

/********************************** Varnish [41-50] ********************************** /

用途：1.HTTP加速器（基于内存或虚拟内存缓存），对静态或部分动态资源的缓存以提高性能
			2.反向代理、负载均衡：Nginx优于Varnish
			3.如果访问量持续增大，
缓存数据迁移，如原来的Varnisi机器宕机，可以使用命令把缓存数据恢复回来
共享内存日志
浏览器先访问Varnish，然后再访问Tomcat
Varnish和Memcached都属于内存级别的缓存加速，Varnish即使服务器重启也会原有的缓存也不丢失（从日志恢复），因此适合页面缓存，而Memcached更适合MysqL数据库缓存，可以大大减少数据库压力。
通过日志分析那些需要缓存，提高命中率
子进程是Varnish真正产生奇迹的地方，他包含一系列线程来执行不同的任务
优化：1.规划缓存大小。如门户首页包括：首页本身文字图片内容；另外是首页链接（1层或2层）的页面或图片等。命中率也很高
			2.产生一个对象的花费多大？如从后端返回不太消耗资源，而你的内存有有限，则只缓存部分最热门的图片，而不是所有图片
			3.使用varnishstat或其他工具监控n_lru_nuked计数器。如有很多LRU活动，是因为空间限制在清除对象，要考虑增加缓存大小
			4.缓存小文件要考虑额外开销，varnish中每个对象的额外花销大概是1K
			5.如一台机器只供Varnish使用，分配缓存大小只分配机器物理内存的50%~70%。
			6.提高命中率方法：1.规划请求和应答，自定义缓存策略。通过VCL写代码来配置想要缓存的内容，并主动设置TTL，
												2.不依赖http header（对代码侵入太大，尽量在Varnish内部解决）
												3.如使用默认策略，就跟踪和分析Http header
												4.在合理范围内，加大TTL
												5.分析日志，哪些该命中没有命中

/********************************** Nginx + Varnish [51-60] ********************************** /
优化：1.缓存的同时尽量节省内存
			2.提高命中率，该缓存的是否缓存（看日志该对象miss/hist）
哪些内容放进Varnish？
	1.静态资源
	2.动态资源
		1.如首页页面，缓存时间缩短，如几分钟更新
		2.如页面中含有动态信息，则先缓存页面，页面展示后，在通过ajax更新页面中的实时数据
		3.含有post提交数据的页面不能缓存，如提交登录或提交订单
		4.客户频繁修改的页面不能缓存，如购物车
缓存到底是放在Ngnix还是Varnish：
	取决于Ngnix读取本地读取文件时间和Varnish读取后台/缓存加网络传输（Varnish将数据传输到Nginx）哪个时间更短
	
/********************************** Memcache [51-60] ********************************** /
Memcache是一个开源的、高性能的、分布式的内存对象缓存系统
用途：1.在内存中缓存数据，减轻数据库压力
			2.缓存热点数据，提高Web应用访问速度
特点：1.服务端不关心分布式
			2.依靠客户端来实现分布式
			3.客户端存储着可以访问到的Memcache服务器列表
			4.在客户端用算法来保证，对同样key值得数据，读写都操作在同一个服务器
			5.内存中键值对，性能好
			6.协议简单（基于问本行），功能强大
			7.基于libevent时间处理，无阻塞通讯，对内存读写快
			8.基于客户端的分布式，服务端多个Memcache之间不互相通讯
2阶段Hash：第一阶段是计算Hash的Key存放在哪台Memcache服务器，第二阶段是实际计算Hash的Key存取数据
调优：
	1.目标：用最少的内存放最多的数据；提高命中率
	2.3个主要调优参数：-n(chunk初始值)、-f(factor增长因子，dufault:1.25)、-I(调整分配slab页的大小，默认1M，最小1k到128M)
限制：1.Item数据量没有限制，只要内存足够（还是需要思考哪些该存、哪些不该存、存多长时间、什么时候清楚）
			2.单进程最大使用内存2G，如需要更多，可分多个端口开启多个Memcache进程
			3.Item最大30天有效期
			4.缺乏认证及安全管制，应放在防火墙后
			5.没有过多考虑数据的永久性问题
			6.最大键长为250字节
			7.单个Item最大数据时1M
			8.最大同时连接数200，最大软连接数1024
			9.不实现任何冗余和容错：忽略、从失效列表移除、启动热备节点、一致性Hash、两次Hash
建议：1.缓存简单的查询结果，如字典等
			2.缓存简单的基于行的查询结果
			3.缓存常用的热点页面
			4.使用分层缓存，如ehcache、oscache等。缓存更接近处理器，加快生成页面速度；在Memcache失效时，增加可靠性
			5.当数据更新时，需要更新缓存。只适合一次写入，多次读取的数据，不是和混合读写数据
			6.预热缓存：写脚本或命令行工具来预先访问页面来填充缓存数据
适用场景：1.分布式应用
					2.数据库前端缓存
					3.服务器间数据关系
					4.变化频繁，查询频繁的数据，但不一定写入数据库，比如用户在线状态
					5.变化不频繁，查询频繁的数据
					
/********************************** ActiveMQ [71-80] ********************************** /					
并发读：Nginx、Varnish
并发写：ActiveMQ
适用场景：1.异步通讯，削峰平谷
					2.一对多通讯
					3.做多个系统的集成，同构、异构
					4.作为RPC的替代
					5.多个应用相互解构
					6.作为事件驱动架构的幕后支撑
					7.提高系统的可伸缩性
					8.适合写操作或业务逻辑复杂，当高并发时，系统会撑不住
					9.可以通过ActiveMQ集群、消费者集群，提升系统可伸缩性
持久化方案：默认是kahaDB。JDBC Store和JDBC Message Store with ActiveMQ Journal的区别：
	1：Jdbc with journal的性能优于jdbc
	2：Jdbc用于master/slave模式的数据库分享
	3：Jdbc with journal不能用于master/slave模式
	4：一般情况下，推荐使用jdbc with journal
	
/********************************** AMQ结合业务功能的开发 [91-100] ********************************** /					
下订单采用ActiveMQ处理，如果并发太大，可以考虑只启动Sender，不启动Receiver，快速返回客户处理完成结果。等高峰过去，再启动Receiver真正减库存。比如秒杀时，可以把参与秒杀的库存先读入内存，在内存中进行减库存计算，如在内存中判断买完了，就结束秒杀。后续再启动Receiver真正减库存。
---存在问题：
	如集群环境中库存如何共享，采用MemCache可否
	中途如宕机后重启，需要重新获取最新库存到内存中
将所有的下订单消息打包，一次性发送到Receiver，Receiver打开一次session，批量一次处理完所有订单减库存，提升速度

/********************************** MogileFS [131-140] ********************************** /		
在spring的控制器获得文件上传后，写入MogileFS步骤：
1.获得文件名
2.根据文件名去获取对应的FileModel
2.1.如果存在就取出来
2.2.如果不存在，就新增几个
3.把文件流式上传到MogileFS里
4.获得远程Paths
5.把这些Paths组织一下，保存到MySql业务表里的remotePath字段里面

当需要缓存的文件越来越多时：
	1.通过Nginx做负载均衡，建立MogileFS集群，比如一个集群专门放服装类图片，一个集群专门放电器图片
当访问越来越大和频繁时：
	1.增加热点数据(当某个数据访问达到一定次数后)缓存，如Varnish或MemCache

FAQ:
1.Memcache中动态条件查询结果如何缓存？					